From 2361a658542f76dc7dd5d86f75d145f90c5e7ce8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Juho=20H=C3=A4m=C3=A4l=C3=A4inen?=
 <juho.hamalainen@jolla.com>
Date: Wed, 15 Feb 2017 12:58:41 +0200
Subject: [PATCH 1018/1021] bluez5-droid: add backend that only acquires or
 releases the transport.

---
 src/modules/bluetooth/backend-droid.c | 112 +++++++++++++++++++++++-----------
 1 file changed, 75 insertions(+), 37 deletions(-)

diff --git a/src/modules/bluetooth/backend-droid.c b/src/modules/bluetooth/backend-droid.c
index 755df9e..ffecfa1 100644
--- a/src/modules/bluetooth/backend-droid.c
+++ b/src/modules/bluetooth/backend-droid.c
@@ -2,6 +2,7 @@
   This file is part of PulseAudio.
 
   Copyright 2013 Jo찾o Paulo Rechi Vita
+            2016 Jolla Ltd. Contact: Juho H채m채l채inen <juho.hamalainen@jolla.com>
 
   PulseAudio is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
@@ -37,6 +38,7 @@
 #define OFONO_SERVICE "org.ofono"
 #define HF_AUDIO_AGENT_INTERFACE OFONO_SERVICE ".HandsfreeAudioAgent"
 #define HF_AUDIO_MANAGER_INTERFACE OFONO_SERVICE ".HandsfreeAudioManager"
+#define HF_AUDIO_CARD_INTERFACE OFONO_SERVICE ".HandsfreeAudioCard"
 
 #define HF_AUDIO_AGENT_PATH "/HandsfreeAudioAgent"
 
@@ -151,13 +153,15 @@ static int socket_accept(int sock)
 
 static int hf_audio_agent_transport_acquire(pa_bluetooth_transport *t, bool optional, size_t *imtu, size_t *omtu) {
     struct hf_audio_card *card = t->userdata;
-    int err;
 
     pa_assert(card);
 
-    if (!optional) {
+    if (!optional && card->fd < 0) {
         DBusMessage *m;
 
+        pa_log_debug("Acquiring transport from ofono for card %s",
+                     card->path);
+
         pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, "org.ofono.HandsfreeAudioCard", "Connect"));
         pa_assert_se(dbus_connection_send(pa_dbus_connection_get(card->backend->connection), m, NULL));
 
@@ -176,13 +180,7 @@ static int hf_audio_agent_transport_acquire(pa_bluetooth_transport *t, bool opti
 
     t->codec = card->codec;
 
-    err = socket_accept(card->fd);
-    if (err < 0) {
-        pa_log_error("Deferred setup failed on fd %d: %s", card->fd, pa_cstrerror(-err));
-        return -1;
-    }
-
-    return card->fd;
+    return -1;
 }
 
 static void hf_audio_agent_transport_release(pa_bluetooth_transport *t) {
@@ -190,18 +188,23 @@ static void hf_audio_agent_transport_release(pa_bluetooth_transport *t) {
 
     pa_assert(card);
 
-    if (t->state <= PA_BLUETOOTH_TRANSPORT_STATE_IDLE) {
-        pa_log_info("Transport %s already released", t->path);
-        return;
-    }
+    pa_log_debug("Trying to release transport for card %s (fd %d)",
+                 card->path, card->fd);
 
-    if (card->fd < 0)
-        return;
+    if (card->fd > 0) {
+        pa_log_debug("Transport available for card %s (fd %d), releasing now",
+                 card->path, card->fd);
 
-    /* shutdown to make sure connection is dropped immediately */
-    shutdown(card->fd, SHUT_RDWR);
-    close(card->fd);
-    card->fd = -1;
+        /* shutdown to make sure connection is dropped immediately */
+        shutdown(card->fd, SHUT_RDWR);
+        close(card->fd);
+        card->fd = -1;
+
+        pa_log_debug("Successfully released transport for card %s", card->path);
+
+        pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_IDLE);
+    } else
+        pa_log_info("Transport %s already released", t->path);
 }
 
 static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char *path, DBusMessageIter *props_i) {
@@ -209,6 +212,7 @@ static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char
     const char *key, *value;
     struct hf_audio_card *card;
     pa_bluetooth_device *d;
+    pa_bluetooth_profile_t profile = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
 
     pa_assert(backend);
     pa_assert(path);
@@ -227,23 +231,30 @@ static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char
         dbus_message_iter_next(&i);
         dbus_message_iter_recurse(&i, &value_i);
 
-        if ((c = dbus_message_iter_get_arg_type(&value_i)) != DBUS_TYPE_STRING) {
-            pa_log_error("Invalid properties for %s: expected 's', received '%c'", path, c);
-            goto fail;
-        }
+        if ((c = dbus_message_iter_get_arg_type(&value_i)) == DBUS_TYPE_STRING) {
+            dbus_message_iter_get_basic(&value_i, &value);
+
+            if (pa_streq(key, "Type")) {
+                if (pa_streq(value, "gateway"))
+                    profile = PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT;
+                else if (pa_streq(value, "handsfree"))
+                    profile = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
+            } else if (pa_streq(key, "RemoteAddress")) {
+                pa_xfree(card->remote_address);
+                card->remote_address = pa_xstrdup(value);
+            } else if (pa_streq(key, "LocalAddress")) {
+                pa_xfree(card->local_address);
+                card->local_address = pa_xstrdup(value);
+            }
 
-        dbus_message_iter_get_basic(&value_i, &value);
+            pa_log_debug("%s: %s", key, value);
 
-        if (pa_streq(key, "RemoteAddress")) {
-            pa_xfree(card->remote_address);
-            card->remote_address = pa_xstrdup(value);
-        } else if (pa_streq(key, "LocalAddress")) {
-            pa_xfree(card->local_address);
-            card->local_address = pa_xstrdup(value);
+        } else if ((c = dbus_message_iter_get_arg_type(&value_i)) == DBUS_TYPE_UINT16) {
+            /* Ignore for now */
+        } else {
+            pa_log_error("Invalid properties for %s: expected 's' or 'q', received '%c'", path, c);
         }
 
-        pa_log_debug("%s: %s", key, value);
-
         dbus_message_iter_next(props_i);
     }
 
@@ -253,7 +264,7 @@ static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char
         goto fail;
     }
 
-    card->transport = pa_bluetooth_transport_new(d, backend->ofono_bus_id, path, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY, NULL, 0);
+    card->transport = pa_bluetooth_transport_new(d, backend->ofono_bus_id, path, PA_BLUETOOTH_PROFILE_DROID_HEADSET, NULL, 0);
     card->transport->acquire = hf_audio_agent_transport_acquire;
     card->transport->release = hf_audio_agent_transport_release;
     card->transport->userdata = card;
@@ -502,6 +513,20 @@ static DBusMessage *hf_audio_agent_release(DBusConnection *c, DBusMessage *m, vo
     return r;
 }
 
+static const char *bluetooth_transport_state_to_string(pa_bluetooth_transport_state_t state)
+{
+    switch (state) {
+        case PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED:
+            return "disconnected";
+        case PA_BLUETOOTH_TRANSPORT_STATE_IDLE:
+            return "idle";
+        case PA_BLUETOOTH_TRANSPORT_STATE_PLAYING:
+            return "playing";
+    }
+
+    return NULL;
+}
+
 static DBusMessage *hf_audio_agent_new_connection(DBusConnection *c, DBusMessage *m, void *data) {
     DBusMessage *r;
     const char *sender, *path;
@@ -529,12 +554,25 @@ static DBusMessage *hf_audio_agent_new_connection(DBusConnection *c, DBusMessage
 
     card = pa_hashmap_get(backend->cards, path);
 
-    if (!card || codec != HFP_AUDIO_CODEC_CVSD || card->transport->state == PA_BLUETOOTH_TRANSPORT_STATE_PLAYING) {
-        pa_log_warn("New audio connection invalid arguments (path=%s fd=%d, codec=%d)", path, fd, codec);
+    if (!card || codec != HFP_AUDIO_CODEC_CVSD) {
+        pa_log_warn("New audio connection invalid arguments (path=%s fd=%d, codec=%d, transport [state=%s, profile=%s])",
+                    path, fd, codec,
+                    card ? bluetooth_transport_state_to_string(card->transport->state) : "unknown",
+                    card ? pa_bluetooth_profile_to_string(card->transport->profile) : "unknown");
         pa_assert_se(r = dbus_message_new_error(m, "org.ofono.Error.InvalidArguments", "Invalid arguments in method call"));
         return r;
     }
 
+    if (card->transport->state == PA_BLUETOOTH_TRANSPORT_STATE_PLAYING) {
+        pa_log_warn("Could not activate new audio connection as it is already active!? "
+                    "(path=%s fd=%d, codec=%d, transport [state=%s, profile=%s])",
+                    path, fd, codec,
+                    bluetooth_transport_state_to_string(card->transport->state),
+                    pa_bluetooth_profile_to_string(card->transport->profile));
+        pa_assert_se(r = dbus_message_new_error(m, "org.ofono.Error.InvalidArguments", "Transport is already active"));
+        return r;
+    }
+
     pa_log_debug("New audio connection on card %s (fd=%d, codec=%d)", path, fd, codec);
 
     card->fd = fd;
@@ -584,7 +622,7 @@ static DBusHandlerResult hf_audio_agent_handler(DBusConnection *c, DBusMessage *
     return DBUS_HANDLER_RESULT_HANDLED;
 }
 
-pa_bluetooth_backend *pa_bluetooth_ofono_backend_new(pa_core *c, pa_bluetooth_discovery *y) {
+pa_bluetooth_backend *pa_bluetooth_droid_backend_new(pa_core *c, pa_bluetooth_discovery *y) {
     pa_bluetooth_backend *backend;
     DBusError err;
     static const DBusObjectPathVTable vtable_hf_audio_agent = {
@@ -637,7 +675,7 @@ pa_bluetooth_backend *pa_bluetooth_ofono_backend_new(pa_core *c, pa_bluetooth_di
     return backend;
 }
 
-void pa_bluetooth_ofono_backend_free(pa_bluetooth_backend *backend) {
+void pa_bluetooth_droid_backend_free(pa_bluetooth_backend *backend) {
     pa_assert(backend);
 
     pa_dbus_free_pending_list(&backend->pending);
-- 
2.7.4

