From aa36c4d22b9c17ded09497ebd5d00514bfabc582 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Juho=20H=C3=A4m=C3=A4l=C3=A4inen?=
 <juho.hamalainen@tieto.com>
Date: Mon, 9 Mar 2015 11:00:35 +0200
Subject: [PATCH 2003/2003] dbus: Use hooks for all events.

Use hooks for already existing events and for some that don't have core
hook defined, define new core hooks and use them.

This patch is pending for upstream, here squashed to one patch instead
of 20 separate ones.
---
 src/modules/dbus/iface-card.c           |  69 ++--
 src/modules/dbus/iface-client.c         |  34 +-
 src/modules/dbus/iface-core.c           | 655 ++++++++++++++++++++------------
 src/modules/dbus/iface-device.c         | 121 ++++--
 src/modules/dbus/iface-module.c         |  41 +-
 src/modules/dbus/iface-sample.c         |  40 +-
 src/modules/dbus/iface-stream.c         | 179 ++++++---
 src/modules/dbus/module-dbus-protocol.c |   5 -
 src/pulsecore/core-scache.c             |  26 +-
 src/pulsecore/core.h                    |   8 +
 src/pulsecore/module.c                  |   4 +
 src/pulsecore/namereg.c                 |   2 +
 12 files changed, 751 insertions(+), 433 deletions(-)

diff --git a/src/modules/dbus/iface-card.c b/src/modules/dbus/iface-card.c
index da975c8..d0f13c9 100644
--- a/src/modules/dbus/iface-card.c
+++ b/src/modules/dbus/iface-card.c
@@ -59,9 +59,9 @@ struct pa_dbusiface_card {
     pa_proplist *proplist;
 
     pa_hook_slot *card_profile_added_slot;
+    pa_hook_slot *card_profile_changed_slot;
 
     pa_dbus_protocol *dbus_protocol;
-    pa_subscription *subscription;
 };
 
 enum property_handler_index {
@@ -432,37 +432,8 @@ static void handle_get_profile_by_name(DBusConnection *conn, DBusMessage *msg, v
     pa_dbus_send_basic_value_reply(conn, msg, DBUS_TYPE_OBJECT_PATH, &profile_path);
 }
 
-static void subscription_cb(pa_core *core, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    pa_dbusiface_card *c = userdata;
-    DBusMessage *signal_msg = NULL;
-
-    pa_assert(core);
-    pa_assert((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_CARD);
-    pa_assert(c);
-
-    /* We can't use idx != c->card->index, because the c->card pointer may
-     * be stale at this point. */
-    if (pa_idxset_get_by_index(core->cards, idx) != c->card)
-        return;
-
-    if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) != PA_SUBSCRIPTION_EVENT_CHANGE)
-        return;
-
-    if (c->active_profile != c->card->active_profile) {
-        const char *object_path;
-
-        c->active_profile = c->card->active_profile;
-        object_path = pa_dbusiface_card_profile_get_path(pa_hashmap_get(c->profiles, c->active_profile->name));
-
-        pa_assert_se(signal_msg = dbus_message_new_signal(c->path,
-                                                          PA_DBUSIFACE_CARD_INTERFACE,
-                                                          signals[SIGNAL_ACTIVE_PROFILE_UPDATED].name));
-        pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
-
-        pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
-        dbus_message_unref(signal_msg);
-        signal_msg = NULL;
-    }
+static void check_card_proplist(pa_dbusiface_card *c) {
+    DBusMessage *signal_msg;
 
     if (!pa_proplist_equal(c->proplist, c->card->proplist)) {
         DBusMessageIter msg_iter;
@@ -477,10 +448,35 @@ static void subscription_cb(pa_core *core, pa_subscription_event_type_t t, uint3
 
         pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
 }
 
+static pa_hook_result_t card_profile_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_card *c = slot_data;
+    pa_card_profile *profile = call_data;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    if (profile->card != c->card)
+        return PA_HOOK_OK;
+
+    c->active_profile = c->card->active_profile;
+
+    object_path = pa_dbusiface_card_profile_get_path(pa_hashmap_get(c->profiles, c->active_profile->name));
+
+    pa_assert_se(signal_msg = dbus_message_new_signal(c->path,
+                                                      PA_DBUSIFACE_CARD_INTERFACE,
+                                                      signals[SIGNAL_ACTIVE_PROFILE_UPDATED].name));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    check_card_proplist(c);
+
+    return PA_HOOK_OK;
+}
+
 static pa_hook_result_t card_profile_added_cb(void *hook_data, void *call_data, void *slot_data) {
     pa_core *core = hook_data;
     pa_dbusiface_card *c = slot_data;
@@ -506,6 +502,8 @@ static pa_hook_result_t card_profile_added_cb(void *hook_data, void *call_data,
     pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
     dbus_message_unref(signal_msg);
 
+    check_card_proplist(c);
+
     return PA_HOOK_OK;
 }
 
@@ -527,7 +525,6 @@ pa_dbusiface_card *pa_dbusiface_card_new(pa_dbusiface_core *core, pa_card *card)
     c->active_profile = card->active_profile;
     c->proplist = pa_proplist_copy(card->proplist);
     c->dbus_protocol = pa_dbus_protocol_get(card->core);
-    c->subscription = pa_subscription_new(card->core, PA_SUBSCRIPTION_MASK_CARD, subscription_cb, c);
 
     PA_HASHMAP_FOREACH(profile, card->profiles, state) {
         pa_dbusiface_card_profile *p = pa_dbusiface_card_profile_new(c, card->core, profile, c->next_profile_index++);
@@ -536,6 +533,8 @@ pa_dbusiface_card *pa_dbusiface_card_new(pa_dbusiface_core *core, pa_card *card)
 
     pa_assert_se(pa_dbus_protocol_add_interface(c->dbus_protocol, c->path, &card_interface_info, c) >= 0);
 
+    c->card_profile_changed_slot = pa_hook_connect(&card->core->hooks[PA_CORE_HOOK_CARD_PROFILE_CHANGED], PA_HOOK_NORMAL,
+                                                   card_profile_changed_cb, c);
     c->card_profile_added_slot = pa_hook_connect(&card->core->hooks[PA_CORE_HOOK_CARD_PROFILE_ADDED], PA_HOOK_NORMAL,
                                                  card_profile_added_cb, c);
 
@@ -548,11 +547,11 @@ void pa_dbusiface_card_free(pa_dbusiface_card *c) {
     pa_assert_se(pa_dbus_protocol_remove_interface(c->dbus_protocol, c->path, card_interface_info.name) >= 0);
 
     pa_hook_slot_free(c->card_profile_added_slot);
+    pa_hook_slot_free(c->card_profile_changed_slot);
 
     pa_hashmap_free(c->profiles);
     pa_proplist_free(c->proplist);
     pa_dbus_protocol_unref(c->dbus_protocol);
-    pa_subscription_free(c->subscription);
 
     pa_xfree(c->path);
     pa_xfree(c);
diff --git a/src/modules/dbus/iface-client.c b/src/modules/dbus/iface-client.c
index 76ad427..455ea45 100644
--- a/src/modules/dbus/iface-client.c
+++ b/src/modules/dbus/iface-client.c
@@ -39,8 +39,9 @@ struct pa_dbusiface_client {
     char *path;
     pa_proplist *proplist;
 
+    pa_hook_slot *client_proplist_changed_slot;
+
     pa_dbus_protocol *dbus_protocol;
-    pa_subscription *subscription;
 };
 
 static void handle_get_index(DBusConnection *conn, DBusMessage *msg, void *userdata);
@@ -381,27 +382,24 @@ static void handle_remove_properties(DBusConnection *conn, DBusMessage *msg, voi
 
     pa_dbus_send_empty_reply(conn, msg);
 
-    if (changed)
+    if (changed) {
+        pa_hook_fire(&c->client->core->hooks[PA_CORE_HOOK_CLIENT_PROPLIST_CHANGED], c->client);
         pa_subscription_post(c->client->core, PA_SUBSCRIPTION_EVENT_CLIENT|PA_SUBSCRIPTION_EVENT_CHANGE, c->client->index);
+    }
 
     dbus_free_string_array(keys);
 }
 
-static void subscription_cb(pa_core *core, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    pa_dbusiface_client *c = userdata;
-    DBusMessage *signal_msg = NULL;
+static pa_hook_result_t client_proplist_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_client *c = slot_data;
+    pa_client *client = call_data;
+    DBusMessage *signal_msg;
 
-    pa_assert(core);
-    pa_assert((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_CLIENT);
     pa_assert(c);
+    pa_assert(client);
 
-    /* We can't use idx != c->client->index, because the c->client pointer may
-     * be stale at this point. */
-    if (pa_idxset_get_by_index(core->clients, idx) != c->client)
-        return;
-
-    if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) != PA_SUBSCRIPTION_EVENT_CHANGE)
-        return;
+    if (c->client != client)
+        return PA_HOOK_OK;
 
     if (!pa_proplist_equal(c->proplist, c->client->proplist)) {
         DBusMessageIter msg_iter;
@@ -416,8 +414,9 @@ static void subscription_cb(pa_core *core, pa_subscription_event_type_t t, uint3
 
         pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
+
+    return PA_HOOK_OK;
 }
 
 pa_dbusiface_client *pa_dbusiface_client_new(pa_dbusiface_core *core, pa_client *client) {
@@ -432,7 +431,8 @@ pa_dbusiface_client *pa_dbusiface_client_new(pa_dbusiface_core *core, pa_client
     c->path = pa_sprintf_malloc("%s/%s%u", PA_DBUS_CORE_OBJECT_PATH, OBJECT_NAME, client->index);
     c->proplist = pa_proplist_copy(client->proplist);
     c->dbus_protocol = pa_dbus_protocol_get(client->core);
-    c->subscription = pa_subscription_new(client->core, PA_SUBSCRIPTION_MASK_CLIENT, subscription_cb, c);
+    c->client_proplist_changed_slot = pa_hook_connect(&client->core->hooks[PA_CORE_HOOK_CLIENT_PROPLIST_CHANGED],
+                                                      PA_HOOK_NORMAL, client_proplist_changed_cb, c);
 
     pa_assert_se(pa_dbus_protocol_add_interface(c->dbus_protocol, c->path, &client_interface_info, c) >= 0);
 
@@ -444,9 +444,9 @@ void pa_dbusiface_client_free(pa_dbusiface_client *c) {
 
     pa_assert_se(pa_dbus_protocol_remove_interface(c->dbus_protocol, c->path, client_interface_info.name) >= 0);
 
+    pa_hook_slot_free(c->client_proplist_changed_slot);
     pa_proplist_free(c->proplist);
     pa_dbus_protocol_unref(c->dbus_protocol);
-    pa_subscription_free(c->subscription);
 
     pa_xfree(c->path);
     pa_xfree(c);
diff --git a/src/modules/dbus/iface-core.c b/src/modules/dbus/iface-core.c
index 4563b3f..0ec2691 100644
--- a/src/modules/dbus/iface-core.c
+++ b/src/modules/dbus/iface-core.c
@@ -91,7 +91,6 @@ static void handle_stop_listening_for_signal(DBusConnection *conn, DBusMessage *
 
 struct pa_dbusiface_core {
     pa_core *core;
-    pa_subscription *subscription;
 
     pa_dbus_protocol *dbus_protocol;
 
@@ -109,6 +108,20 @@ struct pa_dbusiface_core {
     pa_sink *fallback_sink;
     pa_source *fallback_source;
 
+    pa_hook_slot *module_new_slot;
+    pa_hook_slot *module_removed_slot;
+    pa_hook_slot *default_sink_changed_slot;
+    pa_hook_slot *default_source_changed_slot;
+    pa_hook_slot *sample_cache_new_slot;
+    pa_hook_slot *sample_cache_removed_slot;
+    pa_hook_slot *card_put_slot;
+    pa_hook_slot *card_unlink_slot;
+    pa_hook_slot *sink_input_put_slot;
+    pa_hook_slot *sink_input_unlink_slot;
+    pa_hook_slot *source_output_put_slot;
+    pa_hook_slot *source_output_unlink_slot;
+    pa_hook_slot *client_put_slot;
+    pa_hook_slot *client_unlink_slot;
     pa_hook_slot *sink_put_slot;
     pa_hook_slot *sink_unlink_slot;
     pa_hook_slot *source_put_slot;
@@ -1566,290 +1579,402 @@ static void handle_stop_listening_for_signal(DBusConnection *conn, DBusMessage *
     pa_dbus_send_empty_reply(conn, msg);
 }
 
-static void subscription_cb(pa_core *core, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    pa_dbusiface_core *c = userdata;
-    pa_dbusiface_card *card_iface = NULL;
-    pa_dbusiface_device *device_iface = NULL;
-    pa_dbusiface_stream *stream_iface = NULL;
-    pa_dbusiface_sample *sample_iface = NULL;
-    pa_dbusiface_module *module_iface = NULL;
-    pa_dbusiface_client *client_iface = NULL;
+static pa_hook_result_t module_new_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_module * module = call_data;
+    pa_dbusiface_module *module_iface;
+    const char *object_path;
     DBusMessage *signal_msg = NULL;
-    const char *object_path = NULL;
-    pa_sink *new_fallback_sink = NULL;
-    pa_source *new_fallback_source = NULL;
-
-    pa_assert(c);
-
-    switch (t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) {
-        case PA_SUBSCRIPTION_EVENT_SERVER:
-            new_fallback_sink = pa_namereg_get_default_sink(core);
-            new_fallback_source = pa_namereg_get_default_source(core);
-
-            if (c->fallback_sink != new_fallback_sink) {
-                if (c->fallback_sink)
-                    pa_sink_unref(c->fallback_sink);
-                c->fallback_sink = new_fallback_sink ? pa_sink_ref(new_fallback_sink) : NULL;
-
-                if (c->fallback_sink) {
-                    pa_assert_se(device_iface = pa_hashmap_get(c->sinks_by_index, PA_UINT32_TO_PTR(c->fallback_sink->index)));
-                    object_path = pa_dbusiface_device_get_path(device_iface);
-
-                    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                       PA_DBUS_CORE_INTERFACE,
-                                                                       signals[SIGNAL_FALLBACK_SINK_UPDATED].name)));
-                    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
-                    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
-                    dbus_message_unref(signal_msg);
-                    signal_msg = NULL;
-
-                } else {
-                    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                       PA_DBUS_CORE_INTERFACE,
-                                                                       signals[SIGNAL_FALLBACK_SINK_UNSET].name)));
-                    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
-                    dbus_message_unref(signal_msg);
-                    signal_msg = NULL;
-                }
-            }
-
-            if (c->fallback_source != new_fallback_source) {
-                if (c->fallback_source)
-                    pa_source_unref(c->fallback_source);
-                c->fallback_source = new_fallback_source ? pa_source_ref(new_fallback_source) : NULL;
-
-                if (c->fallback_source) {
-                    pa_assert_se(device_iface = pa_hashmap_get(c->sources_by_index, PA_UINT32_TO_PTR(c->fallback_source->index)));
-                    object_path = pa_dbusiface_device_get_path(device_iface);
-
-                    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                       PA_DBUS_CORE_INTERFACE,
-                                                                       signals[SIGNAL_FALLBACK_SOURCE_UPDATED].name)));
-                    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
-                    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
-                    dbus_message_unref(signal_msg);
-                    signal_msg = NULL;
-
-                } else {
-                    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                       PA_DBUS_CORE_INTERFACE,
-                                                                       signals[SIGNAL_FALLBACK_SOURCE_UNSET].name)));
-                    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
-                    dbus_message_unref(signal_msg);
-                    signal_msg = NULL;
-                }
-            }
-            break;
-
-        case PA_SUBSCRIPTION_EVENT_CARD:
-            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_NEW) {
-                if (!(card_iface = pa_hashmap_get(c->cards, PA_UINT32_TO_PTR(idx)))) {
-                    pa_card *card = NULL;
-
-                    if (!(card = pa_idxset_get_by_index(core->cards, idx)))
-                        return; /* The card was removed immediately after creation. */
-
-                    card_iface = pa_dbusiface_card_new(c, card);
-                    pa_hashmap_put(c->cards, PA_UINT32_TO_PTR(idx), card_iface);
-                }
-
-                object_path = pa_dbusiface_card_get_path(card_iface);
-
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_NEW_CARD].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
-
-            } else if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
-                if (!(card_iface = pa_hashmap_remove(c->cards, PA_UINT32_TO_PTR(idx))))
-                    return;
-
-                object_path = pa_dbusiface_card_get_path(card_iface);
-
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_CARD_REMOVED].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
-
-                pa_dbusiface_card_free(card_iface);
-            }
-            break;
-
-        case PA_SUBSCRIPTION_EVENT_SINK_INPUT:
-            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_NEW) {
-                pa_sink_input *sink_input = NULL;
-
-                if (!(sink_input = pa_idxset_get_by_index(core->sink_inputs, idx)))
-                    return; /* The sink input was removed immediately after creation. */
-
-                if (!(stream_iface = pa_hashmap_get(c->playback_streams, PA_UINT32_TO_PTR(idx)))) {
-                    stream_iface = pa_dbusiface_stream_new_playback(c, sink_input);
-                    pa_hashmap_put(c->playback_streams, PA_UINT32_TO_PTR(idx), stream_iface);
-                }
-
-                object_path = pa_dbusiface_stream_get_path(stream_iface);
-
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_NEW_PLAYBACK_STREAM].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
-
-            } else if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
-                if (!(stream_iface = pa_hashmap_remove(c->playback_streams, PA_UINT32_TO_PTR(idx))))
-                    return;
-
-                object_path = pa_dbusiface_stream_get_path(stream_iface);
-
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_PLAYBACK_STREAM_REMOVED].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
-
-                pa_dbusiface_stream_free(stream_iface);
-            }
-            break;
-
-        case PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
-            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_NEW) {
-                pa_source_output *source_output = NULL;
 
-                if (!(source_output = pa_idxset_get_by_index(core->source_outputs, idx)))
-                    return; /* The source output was removed immediately after creation. */
+    pa_assert(c);
+    pa_assert(module);
+
+    if (!(module_iface = pa_hashmap_get(c->modules, PA_UINT32_TO_PTR(module->index)))) {
+        module_iface = pa_dbusiface_module_new(module);
+        pa_assert_se(pa_hashmap_put(c->modules, PA_UINT32_TO_PTR(module->index), module_iface) >= 0);
+
+        object_path = pa_dbusiface_module_get_path(module_iface);
+
+        pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                           PA_DBUS_CORE_INTERFACE,
+                                                           signals[SIGNAL_NEW_MODULE].name)));
+        pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+        pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+        dbus_message_unref(signal_msg);
+    }
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t module_removed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_module * module = call_data;
+    pa_dbusiface_module *module_iface;
+    const char *object_path;
+    DBusMessage *signal_msg = NULL;
+
+    pa_assert(c);
+    pa_assert(module);
+
+    pa_assert_se((module_iface = pa_hashmap_remove(c->modules, PA_UINT32_TO_PTR(module->index))));
 
-                if (!(stream_iface = pa_hashmap_get(c->record_streams, PA_UINT32_TO_PTR(idx)))) {
-                    stream_iface = pa_dbusiface_stream_new_record(c, source_output);
-                    pa_hashmap_put(c->record_streams, PA_UINT32_TO_PTR(idx), stream_iface);
-                }
+    object_path = pa_dbusiface_module_get_path(module_iface);
 
-                object_path = pa_dbusiface_stream_get_path(stream_iface);
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_MODULE_REMOVED].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_NEW_RECORD_STREAM].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+    pa_dbusiface_module_free(module_iface);
 
-            } else if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
-                if (!(stream_iface = pa_hashmap_remove(c->record_streams, PA_UINT32_TO_PTR(idx))))
-                    return;
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
 
-                object_path = pa_dbusiface_stream_get_path(stream_iface);
+    return PA_HOOK_OK;
+}
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_RECORD_STREAM_REMOVED].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+static pa_hook_result_t sample_cache_new_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_scache_entry *sample = call_data;
+    pa_dbusiface_sample *sample_iface;
+    const char *object_path;
+    DBusMessage *signal_msg = NULL;
 
-                pa_dbusiface_stream_free(stream_iface);
-            }
-            break;
+    pa_assert(c);
+    pa_assert(sample);
 
-        case PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE:
-            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_NEW) {
-                pa_scache_entry *sample = NULL;
+    sample_iface = pa_dbusiface_sample_new(c, sample);
+    pa_assert_se(pa_hashmap_put(c->samples, PA_UINT32_TO_PTR(sample->index), sample_iface) >= 0);
 
-                if (!(sample = pa_idxset_get_by_index(core->scache, idx)))
-                    return; /* The sample was removed immediately after creation. */
+    object_path = pa_dbusiface_sample_get_path(sample_iface);
 
-                if (!(sample_iface = pa_hashmap_get(c->samples, PA_UINT32_TO_PTR(idx)))) {
-                    sample_iface = pa_dbusiface_sample_new(c, sample);
-                    pa_hashmap_put(c->samples, PA_UINT32_TO_PTR(idx), sample_iface);
-                }
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_NEW_SAMPLE].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
 
-                object_path = pa_dbusiface_sample_get_path(sample_iface);
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_NEW_SAMPLE].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+    return PA_HOOK_OK;
+}
 
-            } else if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
-                if (!(sample_iface = pa_hashmap_remove(c->samples, PA_UINT32_TO_PTR(idx))))
-                    return;
+static pa_hook_result_t sample_cache_removed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_scache_entry *sample = call_data;
+    pa_dbusiface_sample *sample_iface;
+    const char *object_path;
+    DBusMessage *signal_msg = NULL;
 
-                object_path = pa_dbusiface_sample_get_path(sample_iface);
+    pa_assert(c);
+    pa_assert(sample);
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_SAMPLE_REMOVED].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+    pa_assert_se((sample_iface = pa_hashmap_remove(c->samples, PA_UINT32_TO_PTR(sample->index))));
 
-                pa_dbusiface_sample_free(sample_iface);
-            }
-            break;
+    object_path = pa_dbusiface_sample_get_path(sample_iface);
 
-        case PA_SUBSCRIPTION_EVENT_MODULE:
-            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_NEW) {
-                pa_module *module = NULL;
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_SAMPLE_REMOVED].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
 
-                if (!(module = pa_idxset_get_by_index(core->modules, idx)))
-                    return; /* The module was removed immediately after creation. */
+    pa_dbusiface_sample_free(sample_iface);
 
-                if (!(module_iface = pa_hashmap_get(c->modules, PA_UINT32_TO_PTR(idx)))) {
-                    module_iface = pa_dbusiface_module_new(module);
-                    pa_hashmap_put(c->modules, PA_UINT32_TO_PTR(idx), module_iface);
-                }
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
 
-                object_path = pa_dbusiface_module_get_path(module_iface);
+    return PA_HOOK_OK;
+}
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_NEW_MODULE].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+static pa_hook_result_t default_sink_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_sink *new_fallback_sink = call_data;
+    pa_dbusiface_device *device_iface;
+    const char *object_path;
+    DBusMessage *signal_msg = NULL;
 
-            } else if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
-                if (!(module_iface = pa_hashmap_remove(c->modules, PA_UINT32_TO_PTR(idx))))
-                    return;
+    pa_assert(c);
 
-                object_path = pa_dbusiface_module_get_path(module_iface);
+    if (c->fallback_sink != new_fallback_sink) {
+        if (c->fallback_sink)
+            pa_sink_unref(c->fallback_sink);
+        c->fallback_sink = new_fallback_sink ? pa_sink_ref(new_fallback_sink) : NULL;
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_MODULE_REMOVED].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+        if (c->fallback_sink) {
+            pa_assert_se((device_iface = pa_hashmap_get(c->sinks_by_index, PA_UINT32_TO_PTR(c->fallback_sink->index))));
+            object_path = pa_dbusiface_device_get_path(device_iface);
 
-                pa_dbusiface_module_free(module_iface);
-            }
-            break;
+            pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                               PA_DBUS_CORE_INTERFACE,
+                                                               signals[SIGNAL_FALLBACK_SINK_UPDATED].name)));
+            pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
 
-        case PA_SUBSCRIPTION_EVENT_CLIENT:
-            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_NEW) {
-                pa_client *client = NULL;
+        } else {
+            pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                               PA_DBUS_CORE_INTERFACE,
+                                                               signals[SIGNAL_FALLBACK_SINK_UNSET].name)));
+        }
+    }
 
-                if (!(client = pa_idxset_get_by_index(core->clients, idx)))
-                    return; /* The client was removed immediately after creation. */
+    if (signal_msg) {
+        pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+        dbus_message_unref(signal_msg);
+    }
 
-                if (!(client_iface = pa_hashmap_get(c->clients, PA_UINT32_TO_PTR(idx)))) {
-                    client_iface = pa_dbusiface_client_new(c, client);
-                    pa_hashmap_put(c->clients, PA_UINT32_TO_PTR(idx), client_iface);
-                }
+    return PA_HOOK_OK;
+}
 
-                object_path = pa_dbusiface_client_get_path(client_iface);
+static pa_hook_result_t default_source_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_source *new_fallback_source = call_data;
+    pa_dbusiface_device *device_iface;
+    const char *object_path;
+    DBusMessage *signal_msg = NULL;
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_NEW_CLIENT].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+    pa_assert(c);
 
-            } else if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
-                if (!(client_iface = pa_hashmap_remove(c->clients, PA_UINT32_TO_PTR(idx))))
-                    return;
+    if (c->fallback_source != new_fallback_source) {
+        if (c->fallback_source)
+            pa_source_unref(c->fallback_source);
+        c->fallback_source = new_fallback_source ? pa_source_ref(new_fallback_source) : NULL;
 
-                object_path = pa_dbusiface_client_get_path(client_iface);
+        if (c->fallback_source) {
+            pa_assert_se((device_iface = pa_hashmap_get(c->sources_by_index, PA_UINT32_TO_PTR(c->fallback_source->index))));
+            object_path = pa_dbusiface_device_get_path(device_iface);
 
-                pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
-                                                                   PA_DBUS_CORE_INTERFACE,
-                                                                   signals[SIGNAL_CLIENT_REMOVED].name)));
-                pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+            pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                               PA_DBUS_CORE_INTERFACE,
+                                                               signals[SIGNAL_FALLBACK_SOURCE_UPDATED].name)));
+            pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
 
-                pa_dbusiface_client_free(client_iface);
-            }
-            break;
+        } else {
+            pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                               PA_DBUS_CORE_INTERFACE,
+                                                               signals[SIGNAL_FALLBACK_SOURCE_UNSET].name)));
+        }
     }
 
     if (signal_msg) {
         pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
     }
+
+    return PA_HOOK_OK;
+}
+
+
+
+static pa_hook_result_t card_put_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_card *card = call_data;
+    pa_dbusiface_card *card_iface = NULL;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(card);
+
+    card_iface = pa_dbusiface_card_new(c, card);
+    pa_assert_se(pa_hashmap_put(c->cards, PA_UINT32_TO_PTR(card->index), card_iface) >= 0);
+
+    object_path = pa_dbusiface_card_get_path(card_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_NEW_CARD].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t card_unlink_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_card *card = call_data;
+    pa_dbusiface_card *card_iface;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(card);
+
+    pa_assert_se((card_iface = pa_hashmap_remove(c->cards, PA_UINT32_TO_PTR(card->index))));
+
+    object_path = pa_dbusiface_card_get_path(card_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_CARD_REMOVED].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbusiface_card_free(card_iface);
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t sink_input_put_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_sink_input *sink_input = call_data;
+    pa_dbusiface_stream *stream_iface;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(sink_input);
+
+    stream_iface = pa_dbusiface_stream_new_playback(c, sink_input);
+    pa_assert_se(pa_hashmap_put(c->playback_streams, PA_UINT32_TO_PTR(sink_input->index), stream_iface) >= 0);
+
+    object_path = pa_dbusiface_stream_get_path(stream_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_NEW_PLAYBACK_STREAM].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t sink_input_unlink_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_sink_input *sink_input = call_data;
+    pa_dbusiface_stream *stream_iface;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(sink_input);
+
+    pa_assert_se((stream_iface = pa_hashmap_remove(c->playback_streams, PA_UINT32_TO_PTR(sink_input->index))));
+
+    object_path = pa_dbusiface_stream_get_path(stream_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_PLAYBACK_STREAM_REMOVED].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbusiface_stream_free(stream_iface);
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t source_output_put_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_source_output *source_output = call_data;
+    pa_dbusiface_stream *stream_iface;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(source_output);
+
+    stream_iface = pa_dbusiface_stream_new_record(c, source_output);
+    pa_assert_se(pa_hashmap_put(c->record_streams, PA_UINT32_TO_PTR(source_output->index), stream_iface) >= 0);
+
+    object_path = pa_dbusiface_stream_get_path(stream_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_NEW_RECORD_STREAM].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t source_output_unlink_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_source_output *source_output = call_data;
+    pa_dbusiface_stream *stream_iface;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(source_output);
+
+    pa_assert_se((stream_iface = pa_hashmap_remove(c->record_streams, PA_UINT32_TO_PTR(source_output->index))));
+
+    object_path = pa_dbusiface_stream_get_path(stream_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_RECORD_STREAM_REMOVED].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbusiface_stream_free(stream_iface);
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t client_put_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_client *client = call_data;
+    pa_dbusiface_client *client_iface;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(client);
+
+    client_iface = pa_dbusiface_client_new(c, client);
+    pa_assert_se(pa_hashmap_put(c->clients, PA_UINT32_TO_PTR(client->index), client_iface) >= 0);
+
+    object_path = pa_dbusiface_client_get_path(client_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_NEW_CLIENT].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t client_unlink_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_core *c = slot_data;
+    pa_client *client = call_data;
+    pa_dbusiface_client *client_iface;
+    const char *object_path;
+    DBusMessage *signal_msg;
+
+    pa_assert(c);
+    pa_assert(client);
+
+    pa_assert_se((client_iface = pa_hashmap_remove(c->clients, PA_UINT32_TO_PTR(client->index))));
+
+    object_path = pa_dbusiface_client_get_path(client_iface);
+
+    pa_assert_se((signal_msg = dbus_message_new_signal(PA_DBUS_CORE_OBJECT_PATH,
+                                                       PA_DBUS_CORE_INTERFACE,
+                                                       signals[SIGNAL_CLIENT_REMOVED].name)));
+    pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_OBJECT_PATH, &object_path, DBUS_TYPE_INVALID));
+
+    pa_dbusiface_client_free(client_iface);
+
+    pa_dbus_protocol_send_signal(c->dbus_protocol, signal_msg);
+    dbus_message_unref(signal_msg);
+
+    return PA_HOOK_OK;
 }
 
 static pa_hook_result_t sink_put_cb(void *hook_data, void *call_data, void *slot_data) {
@@ -2015,7 +2140,6 @@ pa_dbusiface_core *pa_dbusiface_core_new(pa_core *core) {
 
     c = pa_xnew(pa_dbusiface_core, 1);
     c->core = core;
-    c->subscription = pa_subscription_new(core, PA_SUBSCRIPTION_MASK_ALL, subscription_cb, c);
     c->dbus_protocol = pa_dbus_protocol_get(core);
     c->cards = pa_hashmap_new_full(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func, NULL, (pa_free_cb_t) pa_dbusiface_card_free);
     c->sinks_by_index = pa_hashmap_new_full(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func, NULL,
@@ -2033,6 +2157,34 @@ pa_dbusiface_core *pa_dbusiface_core_new(pa_core *core) {
     c->clients = pa_hashmap_new_full(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func, NULL, (pa_free_cb_t) pa_dbusiface_client_free);
     c->fallback_sink = pa_namereg_get_default_sink(core);
     c->fallback_source = pa_namereg_get_default_source(core);
+    c->module_new_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_MODULE_NEW],
+                                         PA_HOOK_NORMAL, module_new_cb, c);
+    c->module_removed_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_MODULE_REMOVED],
+                                             PA_HOOK_NORMAL, module_removed_cb, c);
+    c->default_sink_changed_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SERVER_DEFAULT_SINK_CHANGED],
+                                                   PA_HOOK_NORMAL, default_sink_changed_cb, c);
+    c->default_source_changed_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SERVER_DEFAULT_SOURCE_CHANGED],
+                                                     PA_HOOK_NORMAL, default_source_changed_cb, c);
+    c->sample_cache_new_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SAMPLE_CACHE_NEW],
+                                               PA_HOOK_NORMAL, sample_cache_new_cb, c);
+    c->sample_cache_removed_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SAMPLE_CACHE_REMOVED],
+                                                   PA_HOOK_NORMAL, sample_cache_removed_cb, c);
+    c->card_put_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_CARD_PUT],
+                                       PA_HOOK_NORMAL, card_put_cb, c);
+    c->card_unlink_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_CARD_UNLINK],
+                                          PA_HOOK_NORMAL, card_unlink_cb, c);
+    c->sink_input_put_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SINK_INPUT_PUT],
+                                             PA_HOOK_NORMAL, sink_input_put_cb, c);
+    c->sink_input_unlink_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SINK_INPUT_UNLINK],
+                                                PA_HOOK_NORMAL, sink_input_unlink_cb, c);
+    c->source_output_put_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_PUT],
+                                                PA_HOOK_NORMAL, source_output_put_cb, c);
+    c->source_output_unlink_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_UNLINK],
+                                                   PA_HOOK_NORMAL, source_output_unlink_cb, c);
+    c->client_put_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_CLIENT_PUT],
+                                         PA_HOOK_NORMAL, client_put_cb, c);
+    c->client_unlink_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_CLIENT_UNLINK],
+                                            PA_HOOK_NORMAL, client_unlink_cb, c);
     c->sink_put_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SINK_PUT], PA_HOOK_NORMAL, sink_put_cb, c);
     c->sink_unlink_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SINK_UNLINK], PA_HOOK_NORMAL, sink_unlink_cb, c);
     c->source_put_slot = pa_hook_connect(&core->hooks[PA_CORE_HOOK_SOURCE_PUT], PA_HOOK_NORMAL, source_put_cb, c);
@@ -2096,7 +2248,6 @@ void pa_dbusiface_core_free(pa_dbusiface_core *c) {
 
     /* Note that the order of freeing is important below.
      * Do not change it for the sake of tidiness without checking! */
-    pa_subscription_free(c->subscription);
     pa_hashmap_free(c->cards);
     pa_hashmap_free(c->sinks_by_path);
     pa_hashmap_free(c->sinks_by_index);
@@ -2107,6 +2258,20 @@ void pa_dbusiface_core_free(pa_dbusiface_core *c) {
     pa_hashmap_free(c->samples);
     pa_hashmap_free(c->modules);
     pa_hashmap_free(c->clients);
+    pa_hook_slot_free(c->module_new_slot);
+    pa_hook_slot_free(c->module_removed_slot);
+    pa_hook_slot_free(c->default_sink_changed_slot);
+    pa_hook_slot_free(c->default_source_changed_slot);
+    pa_hook_slot_free(c->sample_cache_new_slot);
+    pa_hook_slot_free(c->sample_cache_removed_slot);
+    pa_hook_slot_free(c->card_put_slot);
+    pa_hook_slot_free(c->card_unlink_slot);
+    pa_hook_slot_free(c->sink_input_put_slot);
+    pa_hook_slot_free(c->sink_input_unlink_slot);
+    pa_hook_slot_free(c->source_output_put_slot);
+    pa_hook_slot_free(c->source_output_unlink_slot);
+    pa_hook_slot_free(c->client_put_slot);
+    pa_hook_slot_free(c->client_unlink_slot);
     pa_hook_slot_free(c->sink_put_slot);
     pa_hook_slot_free(c->sink_unlink_slot);
     pa_hook_slot_free(c->source_put_slot);
diff --git a/src/modules/dbus/iface-device.c b/src/modules/dbus/iface-device.c
index efa4141..2c370a8 100644
--- a/src/modules/dbus/iface-device.c
+++ b/src/modules/dbus/iface-device.c
@@ -94,8 +94,13 @@ struct pa_dbusiface_device {
     pa_device_port *active_port;
     pa_proplist *proplist;
 
+    pa_hook_slot *volume_changed_slot;
+    pa_hook_slot *mute_changed_slot;
+    pa_hook_slot *state_changed_slot;
+    pa_hook_slot *port_changed_slot;
+    pa_hook_slot *proplist_changed_slot;
+
     pa_dbus_protocol *dbus_protocol;
-    pa_subscription *subscription;
 };
 
 enum property_handler_index {
@@ -1077,30 +1082,15 @@ static void handle_source_get_all(DBusConnection *conn, DBusMessage *msg, void *
     dbus_message_unref(reply);
 }
 
-static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    pa_dbusiface_device *d = userdata;
+static pa_hook_result_t volume_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_device *d = slot_data;
     DBusMessage *signal_msg = NULL;
     const pa_cvolume *new_volume = NULL;
-    bool new_mute = false;
-    pa_sink_state_t new_sink_state = 0;
-    pa_source_state_t new_source_state = 0;
-    pa_device_port *new_active_port = NULL;
-    pa_proplist *new_proplist = NULL;
     unsigned i = 0;
 
-    pa_assert(c);
-    pa_assert(d);
-
-    if ((d->type == PA_DEVICE_TYPE_SINK && idx != d->sink->index) || (d->type == PA_DEVICE_TYPE_SOURCE && idx != d->source->index))
-        return;
-
-    if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) != PA_SUBSCRIPTION_EVENT_CHANGE)
-        return;
-
-    pa_assert(((d->type == PA_DEVICE_TYPE_SINK)
-                && ((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_SINK))
-              || ((d->type == PA_DEVICE_TYPE_SOURCE)
-                   && ((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_SOURCE)));
+    if ((d->type == PA_DEVICE_TYPE_SINK && d->sink != call_data) ||
+        (d->type == PA_DEVICE_TYPE_SOURCE && d->source != call_data))
+        return PA_HOOK_OK;
 
     new_volume = (d->type == PA_DEVICE_TYPE_SINK)
                  ? pa_sink_get_volume(d->sink, false)
@@ -1124,10 +1114,23 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
         pa_dbus_protocol_send_signal(d->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
 
-    new_mute = (d->type == PA_DEVICE_TYPE_SINK) ? pa_sink_get_mute(d->sink, false) : pa_source_get_mute(d->source, false);
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t mute_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_device *d = slot_data;
+    DBusMessage *signal_msg = NULL;
+    bool new_mute = false;
+
+    if ((d->type == PA_DEVICE_TYPE_SINK && d->sink != call_data) ||
+        (d->type == PA_DEVICE_TYPE_SOURCE && d->source != call_data))
+        return PA_HOOK_OK;
+
+    new_mute = (d->type == PA_DEVICE_TYPE_SINK)
+               ? pa_sink_get_mute(d->sink, false)
+               : pa_source_get_mute(d->source, false);
 
     if (d->mute != new_mute) {
         d->mute = new_mute;
@@ -1139,9 +1142,21 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
         pa_dbus_protocol_send_signal(d->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
 
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t state_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_device *d = slot_data;
+    DBusMessage *signal_msg = NULL;
+    pa_sink_state_t new_sink_state = 0;
+    pa_source_state_t new_source_state = 0;
+
+    if ((d->type == PA_DEVICE_TYPE_SINK && d->sink != call_data) ||
+        (d->type == PA_DEVICE_TYPE_SOURCE && d->source != call_data))
+        return PA_HOOK_OK;
+
     if (d->type == PA_DEVICE_TYPE_SINK)
         new_sink_state = pa_sink_get_state(d->sink);
     else
@@ -1165,9 +1180,20 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
         pa_dbus_protocol_send_signal(d->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
 
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t port_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_device *d = slot_data;
+    DBusMessage *signal_msg = NULL;
+    pa_device_port *new_active_port = NULL;
+
+    if ((d->type == PA_DEVICE_TYPE_SINK && d->sink != call_data) ||
+        (d->type == PA_DEVICE_TYPE_SOURCE && d->source != call_data))
+        return PA_HOOK_OK;
+
     new_active_port = (d->type == PA_DEVICE_TYPE_SINK) ? d->sink->active_port : d->source->active_port;
 
     if (d->active_port != new_active_port) {
@@ -1183,9 +1209,20 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
         pa_dbus_protocol_send_signal(d->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
 
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t proplist_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_device *d = slot_data;
+    DBusMessage *signal_msg = NULL;
+    pa_proplist *new_proplist = NULL;
+
+    if ((d->type == PA_DEVICE_TYPE_SINK && d->sink != call_data) ||
+        (d->type == PA_DEVICE_TYPE_SOURCE && d->source != call_data))
+        return PA_HOOK_OK;
+
     new_proplist = (d->type == PA_DEVICE_TYPE_SINK) ? d->sink->proplist : d->source->proplist;
 
     if (!pa_proplist_equal(d->proplist, new_proplist)) {
@@ -1201,8 +1238,9 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
         pa_dbus_protocol_send_signal(d->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
+
+    return PA_HOOK_OK;
 }
 
 pa_dbusiface_device *pa_dbusiface_device_new_sink(pa_dbusiface_core *core, pa_sink *sink) {
@@ -1226,7 +1264,16 @@ pa_dbusiface_device *pa_dbusiface_device_new_sink(pa_dbusiface_core *core, pa_si
     d->active_port = sink->active_port;
     d->proplist = pa_proplist_copy(sink->proplist);
     d->dbus_protocol = pa_dbus_protocol_get(sink->core);
-    d->subscription = pa_subscription_new(sink->core, PA_SUBSCRIPTION_MASK_SINK, subscription_cb, d);
+    d->volume_changed_slot = pa_hook_connect(&sink->core->hooks[PA_CORE_HOOK_SINK_VOLUME_CHANGED],
+                                             PA_HOOK_NORMAL, volume_changed_cb, d);
+    d->mute_changed_slot = pa_hook_connect(&sink->core->hooks[PA_CORE_HOOK_SINK_MUTE_CHANGED],
+                                           PA_HOOK_NORMAL, mute_changed_cb, d);
+    d->state_changed_slot = pa_hook_connect(&sink->core->hooks[PA_CORE_HOOK_SINK_STATE_CHANGED],
+                                            PA_HOOK_NORMAL, state_changed_cb, d);
+    d->port_changed_slot = pa_hook_connect(&sink->core->hooks[PA_CORE_HOOK_SINK_PORT_CHANGED],
+                                           PA_HOOK_NORMAL, port_changed_cb, d);
+    d->proplist_changed_slot = pa_hook_connect(&sink->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
+                                               PA_HOOK_NORMAL, proplist_changed_cb, d);
 
     PA_HASHMAP_FOREACH(port, sink->ports, state) {
         pa_dbusiface_device_port *p = pa_dbusiface_device_port_new(d, sink->core, port, d->next_port_index++);
@@ -1260,7 +1307,16 @@ pa_dbusiface_device *pa_dbusiface_device_new_source(pa_dbusiface_core *core, pa_
     d->active_port = source->active_port;
     d->proplist = pa_proplist_copy(source->proplist);
     d->dbus_protocol = pa_dbus_protocol_get(source->core);
-    d->subscription = pa_subscription_new(source->core, PA_SUBSCRIPTION_MASK_SOURCE, subscription_cb, d);
+    d->volume_changed_slot = pa_hook_connect(&source->core->hooks[PA_CORE_HOOK_SOURCE_VOLUME_CHANGED],
+                                             PA_HOOK_NORMAL, volume_changed_cb, d);
+    d->mute_changed_slot = pa_hook_connect(&source->core->hooks[PA_CORE_HOOK_SOURCE_MUTE_CHANGED],
+                                           PA_HOOK_NORMAL, mute_changed_cb, d);
+    d->state_changed_slot = pa_hook_connect(&source->core->hooks[PA_CORE_HOOK_SOURCE_STATE_CHANGED],
+                                            PA_HOOK_NORMAL, state_changed_cb, d);
+    d->port_changed_slot = pa_hook_connect(&source->core->hooks[PA_CORE_HOOK_SOURCE_PORT_CHANGED],
+                                           PA_HOOK_NORMAL, port_changed_cb, d);
+    d->proplist_changed_slot = pa_hook_connect(&source->core->hooks[PA_CORE_HOOK_SOURCE_PROPLIST_CHANGED],
+                                               PA_HOOK_NORMAL, proplist_changed_cb, d);
 
     PA_HASHMAP_FOREACH(port, source->ports, state) {
         pa_dbusiface_device_port *p = pa_dbusiface_device_port_new(d, source->core, port, d->next_port_index++);
@@ -1276,6 +1332,12 @@ pa_dbusiface_device *pa_dbusiface_device_new_source(pa_dbusiface_core *core, pa_
 void pa_dbusiface_device_free(pa_dbusiface_device *d) {
     pa_assert(d);
 
+    pa_hook_slot_free(d->volume_changed_slot);
+    pa_hook_slot_free(d->mute_changed_slot);
+    pa_hook_slot_free(d->state_changed_slot);
+    pa_hook_slot_free(d->port_changed_slot);
+    pa_hook_slot_free(d->proplist_changed_slot);
+
     pa_assert_se(pa_dbus_protocol_remove_interface(d->dbus_protocol, d->path, device_interface_info.name) >= 0);
 
     if (d->type == PA_DEVICE_TYPE_SINK) {
@@ -1289,7 +1351,6 @@ void pa_dbusiface_device_free(pa_dbusiface_device *d) {
     pa_hashmap_free(d->ports);
     pa_proplist_free(d->proplist);
     pa_dbus_protocol_unref(d->dbus_protocol);
-    pa_subscription_free(d->subscription);
 
     pa_xfree(d->path);
     pa_xfree(d);
diff --git a/src/modules/dbus/iface-module.c b/src/modules/dbus/iface-module.c
index 95a465c..222cd73 100644
--- a/src/modules/dbus/iface-module.c
+++ b/src/modules/dbus/iface-module.c
@@ -36,7 +36,7 @@ struct pa_dbusiface_module {
     pa_proplist *proplist;
 
     pa_dbus_protocol *dbus_protocol;
-    pa_subscription *subscription;
+    pa_hook_slot *module_proplist_changed_slot;
 };
 
 static void handle_get_index(DBusConnection *conn, DBusMessage *msg, void *userdata);
@@ -264,37 +264,33 @@ static void handle_unload(DBusConnection *conn, DBusMessage *msg, void *userdata
     pa_dbus_send_empty_reply(conn, msg);
 }
 
-static void subscription_cb(pa_core *core, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    pa_dbusiface_module *m = userdata;
-    DBusMessage *signal_msg = NULL;
-
-    pa_assert(core);
-    pa_assert((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_MODULE);
-    pa_assert(m);
+static pa_hook_result_t module_proplist_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_module *module_iface = slot_data;
+    pa_module * module = call_data;
+    DBusMessage *signal_msg;
 
-    /* We can't use idx != m->module->index, because the m->module pointer may
-     * be stale at this point. */
-    if (pa_idxset_get_by_index(core->modules, idx) != m->module)
-        return;
+    pa_assert(module_iface);
+    pa_assert(module);
 
-    if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) != PA_SUBSCRIPTION_EVENT_CHANGE)
-        return;
+    if (module_iface->module != module)
+        return PA_HOOK_OK;
 
-    if (!pa_proplist_equal(m->proplist, m->module->proplist)) {
+    if (!pa_proplist_equal(module_iface->proplist, module->proplist)) {
         DBusMessageIter msg_iter;
 
-        pa_proplist_update(m->proplist, PA_UPDATE_SET, m->module->proplist);
+        pa_proplist_update(module_iface->proplist, PA_UPDATE_SET, module->proplist);
 
-        pa_assert_se(signal_msg = dbus_message_new_signal(m->path,
+        pa_assert_se(signal_msg = dbus_message_new_signal(module_iface->path,
                                                           PA_DBUSIFACE_MODULE_INTERFACE,
                                                           signals[SIGNAL_PROPERTY_LIST_UPDATED].name));
         dbus_message_iter_init_append(signal_msg, &msg_iter);
-        pa_dbus_append_proplist(&msg_iter, m->proplist);
+        pa_dbus_append_proplist(&msg_iter, module_iface->proplist);
 
-        pa_dbus_protocol_send_signal(m->dbus_protocol, signal_msg);
+        pa_dbus_protocol_send_signal(module_iface->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
+
+    return PA_HOOK_OK;
 }
 
 pa_dbusiface_module *pa_dbusiface_module_new(pa_module *module) {
@@ -307,7 +303,8 @@ pa_dbusiface_module *pa_dbusiface_module_new(pa_module *module) {
     m->path = pa_sprintf_malloc("%s/%s%u", PA_DBUS_CORE_OBJECT_PATH, OBJECT_NAME, module->index);
     m->proplist = pa_proplist_copy(module->proplist);
     m->dbus_protocol = pa_dbus_protocol_get(module->core);
-    m->subscription = pa_subscription_new(module->core, PA_SUBSCRIPTION_MASK_MODULE, subscription_cb, m);
+    m->module_proplist_changed_slot = pa_hook_connect(&module->core->hooks[PA_CORE_HOOK_MODULE_PROPLIST_CHANGED],
+                                                      PA_HOOK_NORMAL, module_proplist_changed_cb, m);
 
     pa_assert_se(pa_dbus_protocol_add_interface(m->dbus_protocol, m->path, &module_interface_info, m) >= 0);
 
@@ -321,7 +318,7 @@ void pa_dbusiface_module_free(pa_dbusiface_module *m) {
 
     pa_proplist_free(m->proplist);
     pa_dbus_protocol_unref(m->dbus_protocol);
-    pa_subscription_free(m->subscription);
+    pa_hook_slot_free(m->module_proplist_changed_slot);
 
     pa_xfree(m->path);
     pa_xfree(m);
diff --git a/src/modules/dbus/iface-sample.c b/src/modules/dbus/iface-sample.c
index 319c18e..242ed0d 100644
--- a/src/modules/dbus/iface-sample.c
+++ b/src/modules/dbus/iface-sample.c
@@ -38,7 +38,7 @@ struct pa_dbusiface_sample {
     pa_proplist *proplist;
 
     pa_dbus_protocol *dbus_protocol;
-    pa_subscription *subscription;
+    pa_hook_slot *sample_cache_changed_slot;
 };
 
 static void handle_get_index(DBusConnection *conn, DBusMessage *msg, void *userdata);
@@ -446,36 +446,33 @@ static void handle_remove(DBusConnection *conn, DBusMessage *msg, void *userdata
     pa_dbus_send_empty_reply(conn, msg);
 }
 
-static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    pa_dbusiface_sample *s = userdata;
-    DBusMessage *signal_msg = NULL;
-
-    pa_assert(c);
-    pa_assert(s);
+static pa_hook_result_t sample_cache_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_sample *sample_iface = slot_data;
+    pa_scache_entry *sample = call_data;
+    DBusMessage *signal_msg;
 
-    /* We can't use idx != s->sample->index, because the s->sample pointer may
-     * be stale at this point. */
-    if (pa_idxset_get_by_index(c->scache, idx) != s->sample)
-        return;
+    pa_assert(sample);
+    pa_assert(sample_iface);
 
-    if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) != PA_SUBSCRIPTION_EVENT_CHANGE)
-        return;
+    if (sample_iface->sample != sample)
+        return PA_HOOK_OK;
 
-    if (!pa_proplist_equal(s->proplist, s->sample->proplist)) {
+    if (!pa_proplist_equal(sample_iface->proplist, sample_iface->sample->proplist)) {
         DBusMessageIter msg_iter;
 
-        pa_proplist_update(s->proplist, PA_UPDATE_SET, s->sample->proplist);
+        pa_proplist_update(sample_iface->proplist, PA_UPDATE_SET, sample_iface->sample->proplist);
 
-        pa_assert_se(signal_msg = dbus_message_new_signal(s->path,
+        pa_assert_se(signal_msg = dbus_message_new_signal(sample_iface->path,
                                                           PA_DBUSIFACE_SAMPLE_INTERFACE,
                                                           signals[SIGNAL_PROPERTY_LIST_UPDATED].name));
         dbus_message_iter_init_append(signal_msg, &msg_iter);
-        pa_dbus_append_proplist(&msg_iter, s->proplist);
+        pa_dbus_append_proplist(&msg_iter, sample_iface->proplist);
 
-        pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
+        pa_dbus_protocol_send_signal(sample_iface->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
+
+    return PA_HOOK_OK;
 }
 
 pa_dbusiface_sample *pa_dbusiface_sample_new(pa_dbusiface_core *core, pa_scache_entry *sample) {
@@ -490,7 +487,8 @@ pa_dbusiface_sample *pa_dbusiface_sample_new(pa_dbusiface_core *core, pa_scache_
     s->path = pa_sprintf_malloc("%s/%s%u", PA_DBUS_CORE_OBJECT_PATH, OBJECT_NAME, sample->index);
     s->proplist = pa_proplist_copy(sample->proplist);
     s->dbus_protocol = pa_dbus_protocol_get(sample->core);
-    s->subscription = pa_subscription_new(sample->core, PA_SUBSCRIPTION_MASK_SAMPLE_CACHE, subscription_cb, s);
+    s->sample_cache_changed_slot = pa_hook_connect(&sample->core->hooks[PA_CORE_HOOK_SAMPLE_CACHE_CHANGED],
+                                                   PA_HOOK_NORMAL, sample_cache_changed_cb, s);
 
     pa_assert_se(pa_dbus_protocol_add_interface(s->dbus_protocol, s->path, &sample_interface_info, s) >= 0);
 
@@ -502,9 +500,9 @@ void pa_dbusiface_sample_free(pa_dbusiface_sample *s) {
 
     pa_assert_se(pa_dbus_protocol_remove_interface(s->dbus_protocol, s->path, sample_interface_info.name) >= 0);
 
+    pa_hook_slot_free(s->sample_cache_changed_slot);
     pa_proplist_free(s->proplist);
     pa_dbus_protocol_unref(s->dbus_protocol);
-    pa_subscription_free(s->subscription);
 
     pa_xfree(s->path);
     pa_xfree(s);
diff --git a/src/modules/dbus/iface-stream.c b/src/modules/dbus/iface-stream.c
index 144817d..ade62ca 100644
--- a/src/modules/dbus/iface-stream.c
+++ b/src/modules/dbus/iface-stream.c
@@ -57,8 +57,12 @@ struct pa_dbusiface_stream {
     bool has_volume;
 
     pa_dbus_protocol *dbus_protocol;
-    pa_subscription *subscription;
     pa_hook_slot *send_event_slot;
+    pa_hook_slot *move_finish_slot;
+    pa_hook_slot *volume_changed_slot;
+    pa_hook_slot *mute_changed_slot;
+    pa_hook_slot *proplist_changed_slot;
+    pa_hook_slot *state_changed_slot;
 };
 
 static void handle_get_index(DBusConnection *conn, DBusMessage *msg, void *userdata);
@@ -657,28 +661,37 @@ static void handle_kill(DBusConnection *conn, DBusMessage *msg, void *userdata)
     pa_dbus_send_empty_reply(conn, msg);
 }
 
-static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    pa_dbusiface_stream *s = userdata;
+static void check_and_signal_rate(pa_dbusiface_stream *s) {
     DBusMessage *signal_msg = NULL;
-    const char *new_device_path = NULL;
     uint32_t new_sample_rate = 0;
-    pa_proplist *new_proplist = NULL;
-    unsigned i = 0;
 
-    pa_assert(c);
     pa_assert(s);
 
-    if ((s->type == STREAM_TYPE_PLAYBACK && idx != s->sink_input->index)
-        || (s->type == STREAM_TYPE_RECORD && idx != s->source_output->index))
-        return;
+    new_sample_rate = (s->type == STREAM_TYPE_PLAYBACK)
+                      ? s->sink_input->sample_spec.rate
+                      : s->source_output->sample_spec.rate;
 
-    if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) != PA_SUBSCRIPTION_EVENT_CHANGE)
-        return;
+    if (s->sample_rate != new_sample_rate) {
+        s->sample_rate = new_sample_rate;
+
+        pa_assert_se(signal_msg = dbus_message_new_signal(s->path,
+                                                          PA_DBUSIFACE_STREAM_INTERFACE,
+                                                          signals[SIGNAL_SAMPLE_RATE_UPDATED].name));
+        pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_UINT32, &s->sample_rate, DBUS_TYPE_INVALID));
+
+        pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
+        dbus_message_unref(signal_msg);
+    }
+}
+
+static pa_hook_result_t move_finish_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_stream *s = slot_data;
+    const char *new_device_path = NULL;
+    DBusMessage *signal_msg = NULL;
 
-    pa_assert(((s->type == STREAM_TYPE_PLAYBACK)
-                && ((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_SINK_INPUT))
-              || ((s->type == STREAM_TYPE_RECORD)
-                   && ((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT)));
+    if ((s->type == STREAM_TYPE_PLAYBACK && s->sink_input != call_data) ||
+        (s->type == STREAM_TYPE_RECORD && s->source_output != call_data))
+        return PA_HOOK_OK;
 
     if (s->type == STREAM_TYPE_PLAYBACK) {
         pa_sink *new_sink = s->sink_input->sink;
@@ -696,7 +709,6 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
             pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
             dbus_message_unref(signal_msg);
-            signal_msg = NULL;
         }
     } else {
         pa_source *new_source = s->source_output->source;
@@ -714,54 +726,62 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
             pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
             dbus_message_unref(signal_msg);
-            signal_msg = NULL;
         }
     }
 
-    new_sample_rate = (s->type == STREAM_TYPE_PLAYBACK) ? s->sink_input->sample_spec.rate : s->source_output->sample_spec.rate;
+    check_and_signal_rate(s);
 
-    if (s->sample_rate != new_sample_rate) {
-        s->sample_rate = new_sample_rate;
-
-        pa_assert_se(signal_msg = dbus_message_new_signal(s->path,
-                                                          PA_DBUSIFACE_STREAM_INTERFACE,
-                                                          signals[SIGNAL_SAMPLE_RATE_UPDATED].name));
-        pa_assert_se(dbus_message_append_args(signal_msg, DBUS_TYPE_UINT32, &s->sample_rate, DBUS_TYPE_INVALID));
+    return PA_HOOK_OK;
+}
 
-        pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
-        dbus_message_unref(signal_msg);
-        signal_msg = NULL;
-    }
+static pa_hook_result_t volume_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_stream *s = slot_data;
+    DBusMessage *signal_msg = NULL;
+    unsigned i = 0;
 
-    if (s->type == STREAM_TYPE_PLAYBACK) {
-        bool new_mute = false;
+    if ((s->type == STREAM_TYPE_PLAYBACK && s->sink_input != call_data) ||
+        (s->type == STREAM_TYPE_RECORD && s->source_output != call_data))
+        return PA_HOOK_OK;
 
-        if (s->has_volume) {
-            pa_cvolume new_volume;
+    if (s->type == STREAM_TYPE_PLAYBACK && s->has_volume) {
+        pa_cvolume new_volume;
 
-            pa_sink_input_get_volume(s->sink_input, &new_volume, true);
+        pa_sink_input_get_volume(s->sink_input, &new_volume, true);
 
-            if (!pa_cvolume_equal(&s->volume, &new_volume)) {
-                dbus_uint32_t volume[PA_CHANNELS_MAX];
-                dbus_uint32_t *volume_ptr = volume;
+        if (!pa_cvolume_equal(&s->volume, &new_volume)) {
+            dbus_uint32_t volume[PA_CHANNELS_MAX];
+            dbus_uint32_t *volume_ptr = volume;
 
-                s->volume = new_volume;
+            s->volume = new_volume;
 
-                for (i = 0; i < s->volume.channels; ++i)
-                    volume[i] = s->volume.values[i];
+            for (i = 0; i < s->volume.channels; ++i)
+                volume[i] = s->volume.values[i];
 
-                pa_assert_se(signal_msg = dbus_message_new_signal(s->path,
-                                                                  PA_DBUSIFACE_STREAM_INTERFACE,
-                                                                  signals[SIGNAL_VOLUME_UPDATED].name));
-                pa_assert_se(dbus_message_append_args(signal_msg,
-                                                      DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32, &volume_ptr, s->volume.channels,
-                                                      DBUS_TYPE_INVALID));
+            pa_assert_se(signal_msg = dbus_message_new_signal(s->path,
+                                                              PA_DBUSIFACE_STREAM_INTERFACE,
+                                                              signals[SIGNAL_VOLUME_UPDATED].name));
+            pa_assert_se(dbus_message_append_args(signal_msg,
+                                                  DBUS_TYPE_ARRAY, DBUS_TYPE_UINT32, &volume_ptr, s->volume.channels,
+                                                  DBUS_TYPE_INVALID));
 
-                pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
-                dbus_message_unref(signal_msg);
-                signal_msg = NULL;
-            }
+            pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
+            dbus_message_unref(signal_msg);
         }
+    }
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t mute_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_stream *s = slot_data;
+    DBusMessage *signal_msg = NULL;
+
+    if ((s->type == STREAM_TYPE_PLAYBACK && s->sink_input != call_data) ||
+        (s->type == STREAM_TYPE_RECORD && s->source_output != call_data))
+        return PA_HOOK_OK;
+
+    if (s->type == STREAM_TYPE_PLAYBACK) {
+        bool new_mute = false;
 
         new_mute = s->sink_input->muted;
 
@@ -779,6 +799,18 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
         }
     }
 
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t proplist_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_stream *s = slot_data;
+    DBusMessage *signal_msg = NULL;
+    pa_proplist *new_proplist = NULL;
+
+    if ((s->type == STREAM_TYPE_PLAYBACK && s->sink_input != call_data) ||
+        (s->type == STREAM_TYPE_RECORD && s->source_output != call_data))
+        return PA_HOOK_OK;
+
     new_proplist = (s->type == STREAM_TYPE_PLAYBACK) ? s->sink_input->proplist : s->source_output->proplist;
 
     if (!pa_proplist_equal(s->proplist, new_proplist)) {
@@ -794,8 +826,23 @@ static void subscription_cb(pa_core *c, pa_subscription_event_type_t t, uint32_t
 
         pa_dbus_protocol_send_signal(s->dbus_protocol, signal_msg);
         dbus_message_unref(signal_msg);
-        signal_msg = NULL;
     }
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t state_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    pa_dbusiface_stream *s = slot_data;
+
+    pa_assert(s);
+
+    if ((s->type == STREAM_TYPE_PLAYBACK && s->sink_input != call_data) ||
+        (s->type == STREAM_TYPE_RECORD && s->source_output != call_data))
+        return PA_HOOK_OK;
+
+    check_and_signal_rate(s);
+
+    return PA_HOOK_OK;
 }
 
 static pa_hook_result_t send_event_cb(void *hook_data, void *call_data, void *slot_data) {
@@ -862,11 +909,20 @@ pa_dbusiface_stream *pa_dbusiface_stream_new_playback(pa_dbusiface_core *core, p
     s->mute = sink_input->muted;
     s->proplist = pa_proplist_copy(sink_input->proplist);
     s->dbus_protocol = pa_dbus_protocol_get(sink_input->core);
-    s->subscription = pa_subscription_new(sink_input->core, PA_SUBSCRIPTION_MASK_SINK_INPUT, subscription_cb, s);
     s->send_event_slot = pa_hook_connect(&sink_input->core->hooks[PA_CORE_HOOK_SINK_INPUT_SEND_EVENT],
                                          PA_HOOK_NORMAL,
                                          send_event_cb,
                                          s);
+    s->move_finish_slot = pa_hook_connect(&sink_input->core->hooks[PA_CORE_HOOK_SINK_INPUT_MOVE_FINISH],
+                                          PA_HOOK_NORMAL, move_finish_cb, s);
+    s->volume_changed_slot = pa_hook_connect(&sink_input->core->hooks[PA_CORE_HOOK_SINK_INPUT_VOLUME_CHANGED],
+                                             PA_HOOK_NORMAL, volume_changed_cb, s);
+    s->mute_changed_slot = pa_hook_connect(&sink_input->core->hooks[PA_CORE_HOOK_SINK_INPUT_MUTE_CHANGED],
+                                           PA_HOOK_NORMAL, mute_changed_cb, s);
+    s->proplist_changed_slot = pa_hook_connect(&sink_input->core->hooks[PA_CORE_HOOK_SINK_INPUT_PROPLIST_CHANGED],
+                                               PA_HOOK_NORMAL, proplist_changed_cb, s);
+    s->state_changed_slot = pa_hook_connect(&sink_input->core->hooks[PA_CORE_HOOK_SINK_INPUT_STATE_CHANGED],
+                                            PA_HOOK_NORMAL, state_changed_cb, s);
 
     pa_assert_se(pa_dbus_protocol_add_interface(s->dbus_protocol, s->path, &stream_interface_info, s) >= 0);
 
@@ -891,11 +947,20 @@ pa_dbusiface_stream *pa_dbusiface_stream_new_record(pa_dbusiface_core *core, pa_
     s->proplist = pa_proplist_copy(source_output->proplist);
     s->has_volume = false;
     s->dbus_protocol = pa_dbus_protocol_get(source_output->core);
-    s->subscription = pa_subscription_new(source_output->core, PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT, subscription_cb, s);
     s->send_event_slot = pa_hook_connect(&source_output->core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_SEND_EVENT],
                                          PA_HOOK_NORMAL,
                                          send_event_cb,
                                          s);
+    s->move_finish_slot = pa_hook_connect(&source_output->core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_MOVE_FINISH],
+                                          PA_HOOK_NORMAL, move_finish_cb, s);
+    s->volume_changed_slot = pa_hook_connect(&source_output->core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_VOLUME_CHANGED],
+                                             PA_HOOK_NORMAL, volume_changed_cb, s);
+    s->mute_changed_slot = pa_hook_connect(&source_output->core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_MUTE_CHANGED],
+                                           PA_HOOK_NORMAL, mute_changed_cb, s);
+    s->proplist_changed_slot = pa_hook_connect(&source_output->core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_PROPLIST_CHANGED],
+                                               PA_HOOK_NORMAL, proplist_changed_cb, s);
+    s->state_changed_slot = pa_hook_connect(&source_output->core->hooks[PA_CORE_HOOK_SOURCE_OUTPUT_STATE_CHANGED],
+                                            PA_HOOK_NORMAL, state_changed_cb, s);
 
     pa_assert_se(pa_dbus_protocol_add_interface(s->dbus_protocol, s->path, &stream_interface_info, s) >= 0);
 
@@ -917,8 +982,12 @@ void pa_dbusiface_stream_free(pa_dbusiface_stream *s) {
 
     pa_proplist_free(s->proplist);
     pa_dbus_protocol_unref(s->dbus_protocol);
-    pa_subscription_free(s->subscription);
     pa_hook_slot_free(s->send_event_slot);
+    pa_hook_slot_free(s->move_finish_slot);
+    pa_hook_slot_free(s->volume_changed_slot);
+    pa_hook_slot_free(s->mute_changed_slot);
+    pa_hook_slot_free(s->proplist_changed_slot);
+    pa_hook_slot_free(s->state_changed_slot);
 
     pa_xfree(s->path);
     pa_xfree(s);
diff --git a/src/modules/dbus/module-dbus-protocol.c b/src/modules/dbus/module-dbus-protocol.c
index 53b90f5..8079d6b 100644
--- a/src/modules/dbus/module-dbus-protocol.c
+++ b/src/modules/dbus/module-dbus-protocol.c
@@ -527,11 +527,6 @@ int pa__init(pa_module *m) {
 
     pa_assert(m);
 
-    pa_log_warn("module-dbus-protocol is currently unsupported, and can sometimes cause PulseAudio crashes.");
-    pa_log_warn("The most popular use cases for module-dbus-protocol are related to changing "
-                "equalizer settings and LADSPA plugin parameters at runtime.");
-    pa_log_warn("If you don't use such functionality, it's possible that you don't actually need this module.");
-
     if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
         pa_log("Failed to parse module arguments.");
         goto fail;
diff --git a/src/pulsecore/core-scache.c b/src/pulsecore/core-scache.c
index 3e12b34..9e88b7b 100644
--- a/src/pulsecore/core-scache.c
+++ b/src/pulsecore/core-scache.c
@@ -79,6 +79,7 @@ static void free_entry(pa_scache_entry *e) {
 
     pa_namereg_unregister(e->core, e->name);
     pa_subscription_post(e->core, PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE|PA_SUBSCRIPTION_EVENT_REMOVE, e->index);
+    pa_hook_fire(&e->core->hooks[PA_CORE_HOOK_SAMPLE_CACHE_REMOVED], e);
     pa_xfree(e->name);
     pa_xfree(e->filename);
     if (e->memchunk.memblock)
@@ -88,7 +89,7 @@ static void free_entry(pa_scache_entry *e) {
     pa_xfree(e);
 }
 
-static pa_scache_entry* scache_add_item(pa_core *c, const char *name) {
+static pa_scache_entry* scache_add_item(pa_core *c, const char *name, bool *new_sample) {
     pa_scache_entry *e;
 
     pa_assert(c);
@@ -104,6 +105,8 @@ static pa_scache_entry* scache_add_item(pa_core *c, const char *name) {
         pa_assert(e->core == c);
 
         pa_subscription_post(c, PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE|PA_SUBSCRIPTION_EVENT_CHANGE, e->index);
+        if (new_sample)
+            *new_sample = false;
     } else {
         e = pa_xnew(pa_scache_entry, 1);
 
@@ -119,6 +122,8 @@ static pa_scache_entry* scache_add_item(pa_core *c, const char *name) {
         pa_idxset_put(c->scache, e, &e->index);
 
         pa_subscription_post(c, PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE|PA_SUBSCRIPTION_EVENT_NEW, e->index);
+        if (new_sample)
+            *new_sample = true;
     }
 
     e->last_used_time = 0;
@@ -137,6 +142,15 @@ static pa_scache_entry* scache_add_item(pa_core *c, const char *name) {
     return e;
 }
 
+static void scache_hook(pa_scache_entry *e, bool new_sample) {
+    pa_assert(e);
+
+    if (new_sample)
+        pa_hook_fire(&e->core->hooks[PA_CORE_HOOK_SAMPLE_CACHE_NEW], e);
+    else
+        pa_hook_fire(&e->core->hooks[PA_CORE_HOOK_SAMPLE_CACHE_CHANGED], e);
+}
+
 int pa_scache_add_item(
         pa_core *c,
         const char *name,
@@ -149,6 +163,7 @@ int pa_scache_add_item(
     pa_scache_entry *e;
     char st[PA_SAMPLE_SPEC_SNPRINT_MAX];
     pa_channel_map tmap;
+    bool new_sample;
 
     pa_assert(c);
     pa_assert(name);
@@ -163,7 +178,7 @@ int pa_scache_add_item(
     if (chunk && chunk->length > PA_SCACHE_ENTRY_SIZE_MAX)
         return -1;
 
-    if (!(e = scache_add_item(c, name)))
+    if (!(e = scache_add_item(c, name, &new_sample)))
         return -1;
 
     pa_sample_spec_init(&e->sample_spec);
@@ -190,6 +205,8 @@ int pa_scache_add_item(
     if (idx)
         *idx = e->index;
 
+    scache_hook(e, new_sample);
+
     pa_log_debug("Created sample \"%s\" (#%d), %lu bytes with sample spec %s",
                  name, e->index, (unsigned long) e->memchunk.length,
                  pa_sample_spec_snprint(st, sizeof(st), &e->sample_spec));
@@ -232,6 +249,7 @@ int pa_scache_add_file(pa_core *c, const char *name, const char *filename, uint3
 
 int pa_scache_add_file_lazy(pa_core *c, const char *name, const char *filename, uint32_t *idx) {
     pa_scache_entry *e;
+    bool new_sample;
 
 #ifdef OS_IS_WIN32
     char buf[MAX_PATH];
@@ -244,7 +262,7 @@ int pa_scache_add_file_lazy(pa_core *c, const char *name, const char *filename,
     pa_assert(name);
     pa_assert(filename);
 
-    if (!(e = scache_add_item(c, name)))
+    if (!(e = scache_add_item(c, name, &new_sample)))
         return -1;
 
     e->lazy = true;
@@ -258,6 +276,8 @@ int pa_scache_add_file_lazy(pa_core *c, const char *name, const char *filename,
     if (idx)
         *idx = e->index;
 
+    scache_hook(e, new_sample);
+
     return 0;
 }
 
diff --git a/src/pulsecore/core.h b/src/pulsecore/core.h
index 7d896bb..a080083 100644
--- a/src/pulsecore/core.h
+++ b/src/pulsecore/core.h
@@ -65,6 +65,14 @@ typedef enum pa_core_state {
 } pa_core_state_t;
 
 typedef enum pa_core_hook {
+    PA_CORE_HOOK_SERVER_DEFAULT_SINK_CHANGED,
+    PA_CORE_HOOK_SERVER_DEFAULT_SOURCE_CHANGED,
+    PA_CORE_HOOK_MODULE_NEW,
+    PA_CORE_HOOK_MODULE_PROPLIST_CHANGED,
+    PA_CORE_HOOK_MODULE_REMOVED,
+    PA_CORE_HOOK_SAMPLE_CACHE_NEW,
+    PA_CORE_HOOK_SAMPLE_CACHE_CHANGED,
+    PA_CORE_HOOK_SAMPLE_CACHE_REMOVED,
     PA_CORE_HOOK_SINK_NEW,
     PA_CORE_HOOK_SINK_FIXATE,
     PA_CORE_HOOK_SINK_PUT,
diff --git a/src/pulsecore/module.c b/src/pulsecore/module.c
index 1081ad3..d79ef07 100644
--- a/src/pulsecore/module.c
+++ b/src/pulsecore/module.c
@@ -192,6 +192,8 @@ pa_module* pa_module_load(pa_core *c, const char *name, const char *argument) {
         pa_modinfo_free(mi);
     }
 
+    pa_hook_fire(&m->core->hooks[PA_CORE_HOOK_MODULE_NEW], m);
+
     return m;
 
 fail:
@@ -232,6 +234,7 @@ static void pa_module_free(pa_module *m) {
     pa_log_info("Unloaded \"%s\" (index: #%u).", m->name, m->index);
 
     pa_subscription_post(m->core, PA_SUBSCRIPTION_EVENT_MODULE|PA_SUBSCRIPTION_EVENT_REMOVE, m->index);
+    pa_hook_fire(&m->core->hooks[PA_CORE_HOOK_MODULE_REMOVED], m);
 
     pa_xfree(m->name);
     pa_xfree(m->argument);
@@ -354,4 +357,5 @@ void pa_module_update_proplist(pa_module *m, pa_update_mode_t mode, pa_proplist
         pa_proplist_update(m->proplist, mode, p);
 
     pa_subscription_post(m->core, PA_SUBSCRIPTION_EVENT_MODULE|PA_SUBSCRIPTION_EVENT_CHANGE, m->index);
+    pa_hook_fire(&m->core->hooks[PA_CORE_HOOK_MODULE_PROPLIST_CHANGED], m);
 }
diff --git a/src/pulsecore/namereg.c b/src/pulsecore/namereg.c
index b2320c0..2a1e671 100644
--- a/src/pulsecore/namereg.c
+++ b/src/pulsecore/namereg.c
@@ -258,6 +258,7 @@ pa_sink* pa_namereg_set_default_sink(pa_core*c, pa_sink *s) {
     if (c->default_sink != s) {
         c->default_sink = s;
         pa_subscription_post(c, PA_SUBSCRIPTION_EVENT_SERVER|PA_SUBSCRIPTION_EVENT_CHANGE, PA_INVALID_INDEX);
+        pa_hook_fire(&c->hooks[PA_CORE_HOOK_SERVER_DEFAULT_SINK_CHANGED], c->default_sink);
     }
 
     return s;
@@ -272,6 +273,7 @@ pa_source* pa_namereg_set_default_source(pa_core*c, pa_source *s) {
     if (c->default_source != s) {
         c->default_source = s;
         pa_subscription_post(c, PA_SUBSCRIPTION_EVENT_SERVER|PA_SUBSCRIPTION_EVENT_CHANGE, PA_INVALID_INDEX);
+        pa_hook_fire(&c->hooks[PA_CORE_HOOK_SERVER_DEFAULT_SOURCE_CHANGED], c->default_source);
     }
 
     return s;
-- 
1.9.1

